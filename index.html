<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Control de Zoom 3D con Gestos de Mano (Pu√±o/Abierta)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10;
            text-align: center;
        }
        #video { 
            position: absolute;
            opacity: 0; 
            pointer-events: none;
            width: 1px;
            height: 1px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <video id="video" autoplay playsinline></video>
    <div id="instructions">
        Inicializando...
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN DE THREE.JS Y VARIABLES DE CONTROL ---

        let scene, camera, renderer;
        let particles, particleGeometry;
        
        let initialPositions; 
        
        // Constantes del sistema
        const PARTICLE_COUNT = 30000; 
        const INITIAL_RADIUS = 15; 
        const MIN_RADIUS = 5;      
        const MAX_RADIUS = 50;     // Aumentado el l√≠mite de expansi√≥n

        let targetRadius = INITIAL_RADIUS; 
        let currentRadius = INITIAL_RADIUS; 
        const RADIUS_STEP = 0.5;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Generaci√≥n de puntos dentro de una esfera para distribuci√≥n uniforme
            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3); 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                do {
                    x = (Math.random() * 2 - 1);
                    y = (Math.random() * 2 - 1);
                    z = (Math.random() * 2 - 1);
                } while (x * x + y * y + z * z > 1); 

                positions[i * 3]     = x * INITIAL_RADIUS;
                positions[i * 3 + 1] = y * INITIAL_RADIUS;
                positions[i * 3 + 2] = z * INITIAL_RADIUS;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            initialPositions = new Float32Array(positions);

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.1,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            renderer.render(scene, camera);
        }

        function updateParticles() {
            
            // Suavizar el cambio de radio
            currentRadius += (targetRadius - currentRadius) * 0.1;

            if (Math.abs(currentRadius - targetRadius) < 0.01) return; 

            const positions = particleGeometry.attributes.position.array;
            
            // Aplicar el escalado
            const scaleFactor = currentRadius / INITIAL_RADIUS;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const index = i * 3;
                
                positions[index]     = initialPositions[index] * scaleFactor;
                positions[index + 1] = initialPositions[index + 1] * scaleFactor;
                positions[index + 2] = initialPositions[index + 2] * scaleFactor;
            }

            particleGeometry.attributes.position.needsUpdate = true;
        }


        // --- 2. CONFIGURACI√ìN DE MEDIAPIPE HANDS Y GESTOS ---

        const videoElement = document.getElementById('video');
        const instructions = document.getElementById('instructions');
        
        // El punto 0 es la base de la palma
        const PALM_BASE_LANDMARK = 0; 

        // Puntas de los dedos (√≠ndice 8, medio 12, anular 16, me√±ique 20)
        const FINGERTIP_LANDMARKS = [8, 12, 16, 20]; 

        // Si la distancia promedio de las puntas de los dedos a la base de la palma 
        // es menor que este umbral (0.25 en coordenadas normalizadas), se considera pu√±o cerrado.
        const CLOSED_FIST_THRESHOLD = 0.25; 

        // Funci√≥n auxiliar para la distancia entre dos hitos 3D (X, Y, Z)
        function calculateDistance3D(l1, l2) {
            return Math.sqrt(
                Math.pow(l1.x - l2.x, 2) + 
                Math.pow(l1.y - l2.y, 2) + 
                Math.pow(l1.z - l2.z, 2)
            );
        }
        
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, 
            minDetectionConfidence: 0.7, 
            minTrackingConfidence: 0.7 
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const palmBase = landmarks[PALM_BASE_LANDMARK];
                let totalDistance = 0;

                // 1. Sumar la distancia de cada punta de dedo a la base de la palma
                FINGERTIP_LANDMARKS.forEach(index => {
                    totalDistance += calculateDistance3D(palmBase, landmarks[index]);
                });
                
                // 2. Calcular la distancia promedio
                const averageDistance = totalDistance / FINGERTIP_LANDMARKS.length;
                
                // 3. Determinar el gesto
                let isFistClosed = averageDistance < CLOSED_FIST_THRESHOLD;
                
                if (isFistClosed) {
                    // Pu√±o Cerrado (Contracci√≥n / Zoom Out)
                    targetRadius = Math.max(MIN_RADIUS, targetRadius - RADIUS_STEP);
                    instructions.textContent = `‚úä PU√ëO CERRADO: Contracci√≥n (Radio: ${targetRadius.toFixed(1)})`;
                } else {
                    // Mano Abierta (Expansi√≥n / Zoom In)
                    targetRadius = Math.min(MAX_RADIUS, targetRadius + RADIUS_STEP);
                    instructions.textContent = `üñêÔ∏è MANO ABIERTA: Expansi√≥n (Radio: ${targetRadius.toFixed(1)})`;
                }

            } else {
                // Si no hay manos, el radio objetivo se mantiene o vuelve lentamente al inicial
                if (targetRadius !== INITIAL_RADIUS) {
                    if (targetRadius > INITIAL_RADIUS) {
                        targetRadius = Math.max(INITIAL_RADIUS, targetRadius - 0.2);
                    } else {
                        targetRadius = Math.min(INITIAL_RADIUS, targetRadius + 0.2);
                    }
                }
                instructions.textContent = 'Mueve tu mano frente a la c√°mara (bien iluminada) para comenzar.';
            }
        });

        // Inicializar la c√°mara (WebCam)
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640, 
            height: 480
        });

        // --- 3. INICIO DE LA APLICACI√ìN ---

        function startApp() {
            initThreeJS();
            animate();
            
            cameraUtils.start().then(() => {
                instructions.textContent = 'C√°mara iniciada. Mueve tu mano para comenzar.';
            }).catch(error => {
                instructions.textContent = 'ERROR: No se pudo acceder a la c√°mara. Revisa permisos.';
                console.error("Error al iniciar la c√°mara:", error);
            });
        }

        instructions.textContent = 'Cargando modelos de MediaPipe...';
        hands.initialize().then(startApp).catch(error => {
            instructions.textContent = 'ERROR al cargar MediaPipe. Revisa la consola para m√°s detalles.';
            console.error("Error al inicializar MediaPipe:", error);
        });

    </script>
</body>
</html>