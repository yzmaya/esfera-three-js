<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Control 3D Completo: Zoom, Color y Rotaci√≥n</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10;
            text-align: center;
        }
        #video { 
            position: absolute;
            opacity: 0; 
            pointer-events: none;
            width: 1px;
            height: 1px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <video id="video" autoplay playsinline></video>
    <div id="instructions">
        Inicializando...
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN DE THREE.JS Y VARIABLES DE CONTROL ---

        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial; 
        let initialPositions; 
        
        // Variables para la rotaci√≥n
        let previousRotationPoint = null;
        const ROTATION_FACTOR = 0.05; // Sensibilidad de la rotaci√≥n

        // Colores y Zooms (restantes del paso anterior)
        const COLOR_RED = new THREE.Color(0xff0000); 
        const COLOR_GREEN = new THREE.Color(0x00ff00); 
        const COLOR_DEFAULT = new THREE.Color(0x00ffff); 

        const PARTICLE_COUNT = 30000; 
        const INITIAL_RADIUS = 15; 
        const MIN_RADIUS = 5;      
        const MAX_RADIUS = 50;     

        let targetRadius = INITIAL_RADIUS; 
        let currentRadius = INITIAL_RADIUS; 
        const RADIUS_STEP = 0.5;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Generaci√≥n de puntos dentro de una esfera
            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3); 
            // ... (c√≥digo de generaci√≥n de esfera omitido por brevedad, es el mismo) ...

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                do {
                    x = (Math.random() * 2 - 1);
                    y = (Math.random() * 2 - 1);
                    z = (Math.random() * 2 - 1);
                } while (x * x + y * y + z * z > 1); 

                positions[i * 3]     = x * INITIAL_RADIUS;
                positions[i * 3 + 1] = y * INITIAL_RADIUS;
                positions[i * 3 + 2] = z * INITIAL_RADIUS;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            initialPositions = new Float32Array(positions);

            particleMaterial = new THREE.PointsMaterial({
                color: COLOR_DEFAULT,
                size: 0.1,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            // La rotaci√≥n se aplica aqu√≠, justo antes del render
            // Aplicamos un suavizado lento para que no se detenga bruscamente
            particles.rotation.y *= 0.99; // Damping
            renderer.render(scene, camera);
        }

        function updateParticles() {
            // ... (c√≥digo de escalado de part√≠culas omitido, es el mismo) ...
            currentRadius += (targetRadius - currentRadius) * 0.1;

            if (Math.abs(currentRadius - targetRadius) > 0.01) { 
                const positions = particleGeometry.attributes.position.array;
                const scaleFactor = currentRadius / INITIAL_RADIUS;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const index = i * 3;
                    positions[index]     = initialPositions[index] * scaleFactor;
                    positions[index + 1] = initialPositions[index + 1] * scaleFactor;
                    positions[index + 2] = initialPositions[index + 2] * scaleFactor;
                }
                particleGeometry.attributes.position.needsUpdate = true;
            }
        }


        // --- 2. CONFIGURACI√ìN DE MEDIAPIPE HANDS Y GESTOS ---

        const videoElement = document.getElementById('video');
        const instructions = document.getElementById('instructions');
        
        const PALM_BASE_LANDMARK = 0; 
        const FINGERTIP_LANDMARKS = [8, 12, 16, 20]; 
        const CLOSED_FIST_THRESHOLD = 0.25; 

        function calculateDistance3D(l1, l2) {
            return Math.sqrt(
                Math.pow(l1.x - l2.x, 2) + 
                Math.pow(l1.y - l2.y, 2) + 
                Math.pow(l1.z - l2.z, 2)
            );
        }
        
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2, // üö® ¬°IMPORTANTE! Permitir dos manos
            modelComplexity: 1, 
            minDetectionConfidence: 0.7, 
            minTrackingConfidence: 0.7 
        });

        hands.onResults((results) => {
            const numHands = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            
            if (numHands > 0) {
                // L√≥gica de Zoom y Color (usando la primera mano detectada)
                const landmarks = results.multiHandLandmarks[0];
                const palmBase = landmarks[PALM_BASE_LANDMARK];
                let totalDistance = 0;

                FINGERTIP_LANDMARKS.forEach(index => {
                    totalDistance += calculateDistance3D(palmBase, landmarks[index]);
                });
                
                const averageDistance = totalDistance / FINGERTIP_LANDMARKS.length;
                let isFistClosed = averageDistance < CLOSED_FIST_THRESHOLD;
                
                // Actualizaci√≥n de Radio y Color (misma l√≥gica)
                if (isFistClosed) {
                    targetRadius = Math.max(MIN_RADIUS, targetRadius - RADIUS_STEP);
                    particleMaterial.color.copy(COLOR_RED);
                    instructions.textContent = `‚úä PU√ëO CERRADO (ROJO): Contracci√≥n. ${numHands} mano(s) detectada(s).`;
                } else {
                    targetRadius = Math.min(MAX_RADIUS, targetRadius + RADIUS_STEP);
                    particleMaterial.color.copy(COLOR_GREEN);
                    instructions.textContent = `üñêÔ∏è MANO ABIERTA (VERDE): Expansi√≥n. ${numHands} mano(s) detectada(s).`;
                }
                
                particleMaterial.needsUpdate = true;

                // üö® L√≥gica de Rotaci√≥n con Dos Manos
                if (numHands === 2) {
                    const hand1Center = results.multiHandLandmarks[0][PALM_BASE_LANDMARK];
                    const hand2Center = results.multiHandLandmarks[1][PALM_BASE_LANDMARK];
                    
                    // Calculamos el punto de control central entre las dos palmas (eje X)
                    const currentRotationPoint = (hand1Center.x + hand2Center.x) / 2;

                    if (previousRotationPoint !== null) {
                        // Delta (diferencia) en el eje X: > 0 girar a la derecha, < 0 girar a la izquierda
                        const deltaX = currentRotationPoint - previousRotationPoint;
                        
                        // Aplicar rotaci√≥n en el eje Y (vertical)
                        particles.rotation.y += deltaX * ROTATION_FACTOR * 5; // Multiplicador de sensibilidad

                        instructions.textContent = `üîÑ DOBLE MANO: ROTANDO (Velocidad: ${(deltaX * 5).toFixed(2)}).`;
                    }
                    
                    // Almacenar el punto actual para el siguiente fotograma
                    previousRotationPoint = currentRotationPoint;
                } else {
                    // Si solo hay una mano, reiniciamos el rastreo de rotaci√≥n
                    previousRotationPoint = null;
                }


            } else {
                // Sin manos detectadas
                
                // Vuelve el radio a la posici√≥n inicial
                if (targetRadius !== INITIAL_RADIUS) {
                    if (targetRadius > INITIAL_RADIUS) {
                        targetRadius = Math.max(INITIAL_RADIUS, targetRadius - 0.2);
                    } else {
                        targetRadius = Math.min(INITIAL_RADIUS, targetRadius + 0.2);
                    }
                }
                
                particleMaterial.color.copy(COLOR_DEFAULT);
                particleMaterial.needsUpdate = true;
                previousRotationPoint = null;
                
                instructions.textContent = 'Mueve tu mano(s) frente a la c√°mara (bien iluminada) para comenzar.';
            }
        });

        // Inicializar la c√°mara (WebCam)
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640, 
            height: 480
        });

        // --- 3. INICIO DE LA APLICACI√ìN ---

        function startApp() {
            initThreeJS();
            animate();
            
            cameraUtils.start().then(() => {
                instructions.textContent = 'C√°mara iniciada. Coloca dos manos y mu√©velas horizontalmente.';
            }).catch(error => {
                instructions.textContent = 'ERROR: No se pudo acceder a la c√°mara. Revisa permisos.';
                console.error("Error al iniciar la c√°mara:", error);
            });
        }

        instructions.textContent = 'Cargando modelos de MediaPipe...';
        hands.initialize().then(startApp).catch(error => {
            instructions.textContent = 'ERROR al cargar MediaPipe. Revisa la consola para m√°s detalles.';
            console.error("Error al inicializar MediaPipe:", error);
        });

    </script>
</body>
</html>